// Tab Pool Manager - inline implementation for Service Worker
class TabPoolManager {
  constructor() {
    this.pool = new Map(); // tabId -> poolEntry
    this.audioCache = new Map(); // notebookId -> audioInfo
    this.maxPoolSize = 5;  // ÊúÄÂ§ß5„Å§„ÅÆ„Çø„Éñ„Çí‰øùÊåÅÔºà„Çà„ÇäÂ§ö„Åè„ÅÆÈü≥Â£∞„ÇíÂêåÊôÇ„Å´ÁÆ°ÁêÜÔºâ
    this.minPoolSize = 0;  // ÊúÄÂàù„ÅØ„Çø„Éñ„Çí‰ΩúÊàê„Åó„Å™„ÅÑ
    this.autoCloseEnabled = true;  // Èü≥Â£∞ÁµÇ‰∫ÜÂæå„ÅÆËá™ÂãïÂâäÈô§„ÇíÊúâÂäπÂåñ
    
    // „Çø„Éñ„Ç∞„É´„Éº„ÉóÁÆ°ÁêÜ
    this.groupId = null;
    this.groupTitle = 'üìö NotebookLM Èü≥Â£∞';
    this.groupColor = 'blue';
  }

  async initialize() {
    console.log('Initializing tab pool manager...');
    
    // Set up tab event listeners
    chrome.tabs.onRemoved.addListener((tabId) => {
      this.handleTabRemoved(tabId);
    });
    
    chrome.tabs.onUpdated.addListener((tabId, changeInfo) => {
      if (changeInfo.status === 'unloaded') {
        this.handleTabCrashed(tabId);
      }
    });
    
    // Create initial pooled tabs
    await this.ensureMinimumPool();
    
    // Start periodic cleanup
    this.startPeriodicCleanup();
    
    console.log('Tab pool manager initialized');
  }

  async ensureMinimumPool() {
    const idleCount = Array.from(this.pool.values()).filter(entry => entry.state === 'idle').length;
    const needed = Math.max(0, this.minPoolSize - idleCount);
    
    for (let i = 0; i < needed; i++) {
      try {
        await this.createPooledTab();
      } catch (error) {
        console.error('Failed to create pooled tab:', error);
      }
    }
  }

  async createPooledTab() {
    if (this.pool.size >= this.maxPoolSize) {
      console.log('Pool is at max size, cannot create new tab');
      return null;
    }
    
    try {
      // ÁèæÂú®„ÅÆ„Ç¶„Ç£„É≥„Éâ„Ç¶„ÇíÂèñÂæóÔºàpopulate„Å™„Åó„ÅßË©¶„ÅôÔºâ
      let tabIndex;
      try {
        const currentWindow = await chrome.windows.getCurrent({ populate: true });
        tabIndex = currentWindow.tabs ? currentWindow.tabs.length : undefined;
      } catch (e) {
        console.warn('Failed to get current window info:', e);
        tabIndex = undefined;
      }
      
      // „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Çø„Éñ„Çí‰ΩúÊàêÔºà„É¶„Éº„Ç∂„Éº„Å´Ë¶ã„Åà„Å™„ÅÑ„Çà„ÅÜ„Å´Ôºâ
      const createProps = {
        url: 'about:blank',
        active: false,  // „Çø„Éñ„Çí„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Åó„Å™„ÅÑ
        pinned: false,
        windowId: chrome.windows.WINDOW_ID_CURRENT,
        selected: false  // Âè§„ÅÑAPI„Å®„ÅÆ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ
      };
      
      // „Çø„Éñ„ÇíÊúÄÂæåÂ∞æ„Å´ÈÖçÁΩÆ
      if (tabIndex !== undefined) {
        createProps.index = tabIndex;
      }
      
      // „Çø„Éñ„Çí‰ΩúÊàê
      console.log('Creating tab with props:', createProps);
      const tab = await chrome.tabs.create(createProps);
      console.log('Tab created:', tab.id, 'active:', tab.active);
      
      // „Çø„Éñ„ÇíÂç≥Â∫ß„Å´„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Å´ÁßªÂãïÔºàÁ¢∫ÂÆü„Å´ÈùûË°®Á§∫„Å´„Åô„ÇãÔºâ
      try {
        await chrome.tabs.update(tab.id, {
          active: false,
          muted: false  // Èü≥Â£∞„ÅØÂá∫Âäõ„Åï„Çå„Çã
        });
        console.log('Tab updated to inactive:', tab.id);
      } catch (e) {
        console.log('Tab update warning:', e);
      }
      
      const poolEntry = {
        tabId: tab.id,
        state: 'idle',
        notebookId: null,
        createdAt: Date.now(),
        lastUsed: null
      };
      
      this.pool.set(tab.id, poolEntry);
      console.log(`Created pooled tab: ${tab.id}`);
      
      // „Çø„Éñ„Çí„Ç∞„É´„Éº„Éó„Å´ËøΩÂä†
      await this.addTabToGroup(tab.id);
      
      return tab.id;
    } catch (error) {
      console.error('Failed to create pooled tab:', error);
      // „Ç®„É©„Éº„ÇíÊäï„Åí„Åö„Å´null„ÇíËøî„Åô
      return null;
    }
  }

  async getAvailableTab(notebookId) {
    // TabFocusManager„ÅßÁèæÂú®„ÅÆ„Çø„Éñ„ÇíË®òÈå≤
    if (tabFocusManager) {
      await tabFocusManager.recordCurrentActiveTab();
    }
    
    // „Åæ„Åö„ÄÅ„Åì„ÅÆ„Éé„Éº„Éà„Éñ„ÉÉ„ÇØ„Å´Êó¢„Å´Ââ≤„ÇäÂΩì„Å¶„Çâ„Çå„Å¶„ÅÑ„Çã„Çø„Éñ„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    for (const [tabId, entry] of this.pool.entries()) {
      if (entry.notebookId === notebookId && await this.isTabAlive(tabId)) {
        console.log(`Reusing existing tab for notebook ${notebookId}: ${tabId}`);
        entry.state = 'in_use';
        entry.lastUsed = Date.now();
        return tabId;
      }
    }
    
    // Check if we have a cached tab for this notebook
    const cachedInfo = this.audioCache.get(notebookId);
    if (cachedInfo && cachedInfo.tabId) {
      const poolEntry = this.pool.get(cachedInfo.tabId);
      if (poolEntry && await this.isTabAlive(cachedInfo.tabId)) {
        poolEntry.state = 'in_use';
        poolEntry.lastUsed = Date.now();
        poolEntry.notebookId = notebookId;
        return cachedInfo.tabId;
      }
    }
    
    // Find an idle tab
    let availableTab = null;
    for (const [tabId, entry] of this.pool.entries()) {
      if (entry.state === 'idle' && await this.isTabAlive(tabId)) {
        availableTab = entry;
        availableTab.tabId = tabId;
        break;
      }
    }
    
    // Create new tab if none available
    if (!availableTab) {
      const newTabId = await this.createPooledTab();
      if (!newTabId) {
        // „Éó„Éº„É´„ÅåÊ∫ÄÊùØ„ÅÆÂ†¥Âêà„ÄÅ‰∏ÄÁï™Âè§„ÅÑ„Çø„Éñ„ÇíÂÜçÂà©Áî®Ôºàidle„Åæ„Åü„ÅØin-useÔºâ
        const oldestTab = Array.from(this.pool.values())
          .sort((a, b) => (a.lastUsed || 0) - (b.lastUsed || 0))[0];
        
        if (oldestTab) {
          availableTab = oldestTab;
          console.log(`Reusing oldest tab (${oldestTab.state}):`, availableTab.tabId);
          
          // ‰ΩøÁî®‰∏≠„ÅÆ„Çø„Éñ„ÅÆÂ†¥Âêà„ÄÅÁèæÂú®„ÅÆÈü≥Â£∞„ÇíÂÅúÊ≠¢
          if (oldestTab.state === 'in-use') {
            try {
              await chrome.tabs.sendMessage(oldestTab.tabId, {
                action: 'controlAudio',
                command: 'pause'
              });
            } catch (e) {
              console.log('Failed to pause audio in reused tab:', e);
            }
          }
        } else {
          throw new Error('No available tabs in pool and cannot create new one');
        }
      } else {
        availableTab = this.pool.get(newTabId);
        availableTab.tabId = newTabId;
      }
    }
    
    // Mark as in use
    availableTab.state = 'in_use';
    availableTab.notebookId = notebookId;
    availableTab.lastUsed = Date.now();
    
    // „Çø„Éñ„ÅåËá™ÂãïÁöÑ„Å´ÂâäÈô§„Åï„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´‰øùË≠∑
    try {
      await chrome.tabs.update(availableTab.tabId, { 
        autoDiscardable: false,
        pinned: false 
      });
    } catch (e) {
      console.log('Failed to protect tab from auto-discard:', e);
    }
    
    return availableTab.tabId;
  }

  async navigateTab(tabId, url) {
    try {
      // „Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Åß„Éä„Éì„Ç≤„Éº„ÉàÔºà„Çø„Éñ„ÇíÂàá„ÇäÊõø„Åà„Å™„ÅÑÔºâ
      await chrome.tabs.update(tabId, { 
        url: url,
        active: false  // „Çø„Éñ„Çí„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Åó„Å™„ÅÑ
      });
      
      // „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥„ÅÆÈñãÂßã„ÇíÂæÖ„Å§
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // „Çø„Éñ„ÅåÂãùÊâã„Å´„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Å™„Çâ„Å™„ÅÑ„Çà„ÅÜÂÜçÁ¢∫Ë™ç
      try {
        const tab = await chrome.tabs.get(tabId);
        if (tab.active) {
          // ÂÖÉ„ÅÆ„Çø„Éñ„Å´Êàª„Åô
          const windows = await chrome.windows.getAll({ populate: true });
          for (const window of windows) {
            const previousTab = window.tabs.find(t => t.id !== tabId && t.active === false);
            if (previousTab) {
              await chrome.tabs.update(previousTab.id, { active: true });
              break;
            }
          }
        }
      } catch (e) {
        console.log('Tab focus check failed:', e);
      }
    } catch (error) {
      console.error('Failed to navigate tab:', error);
      throw error;
    }
  }

  releaseTab(tabId, autoClose = false) {
    const poolEntry = this.pool.get(tabId);
    if (poolEntry) {
      if (autoClose) {
        // Èü≥Â£∞ÂÜçÁîüÁµÇ‰∫ÜÊôÇ„ÅØ„Çø„Éñ„ÇíÂâäÈô§
        try {
          chrome.tabs.remove(tabId);
          console.log(`Auto-closed tab ${tabId} after audio ended`);
          // „Éó„Éº„É´„Åã„Çâ„ÇÇÂâäÈô§
          this.pool.delete(tabId);
          // „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„Çâ„ÇÇÂâäÈô§
          if (poolEntry.notebookId) {
            const cachedInfo = this.audioCache.get(poolEntry.notebookId);
            if (cachedInfo && cachedInfo.tabId === tabId) {
              this.audioCache.delete(poolEntry.notebookId);
            }
          }
        } catch (error) {
          console.error('Failed to auto-close tab:', error);
        }
      } else {
        poolEntry.state = 'idle';
        poolEntry.lastUsed = Date.now();
        console.log(`Released tab ${tabId} back to pool`);
      }
    }
    
    // Ensure we maintain minimum pool size
    setTimeout(() => this.ensureMinimumPool(), 1000);
  }

  getCachedAudioInfo(tabId) {
    const poolEntry = this.pool.get(tabId);
    if (!poolEntry || !poolEntry.notebookId) return null;
    
    return this.audioCache.get(poolEntry.notebookId);
  }

  cacheAudioInfo(tabId, audioInfo) {
    const poolEntry = this.pool.get(tabId);
    if (poolEntry && poolEntry.notebookId) {
      this.audioCache.set(poolEntry.notebookId, {
        ...audioInfo,
        tabId,
        cachedAt: Date.now()
      });
      console.log(`Cached audio info for notebook ${poolEntry.notebookId}`);
    }
  }

  async isTabAlive(tabId) {
    try {
      await chrome.tabs.get(tabId);
      return true;
    } catch {
      return false;
    }
  }

  handleTabRemoved(tabId) {
    const poolEntry = this.pool.get(tabId);
    if (poolEntry) {
      console.log(`Tab ${tabId} was removed from pool`);
      
      // „Ç≠„É£„ÉÉ„Ç∑„É•„Åã„Çâ„ÇÇÂâäÈô§
      if (poolEntry.notebookId) {
        const cachedInfo = this.audioCache.get(poolEntry.notebookId);
        if (cachedInfo && cachedInfo.tabId === tabId) {
          this.audioCache.delete(poolEntry.notebookId);
        }
      }
      
      // ÂÜçÁîü‰∏≠„ÅÆ„Çø„Éñ„ÅÆÂ†¥Âêà„ÅØË≠¶Âëä
      if (poolEntry.state === 'in_use') {
        console.warn(`Active audio tab ${tabId} was removed while in use`);
        
        // „Çµ„Ç§„Éâ„Éë„Éç„É´„Å´ÈÄöÁü•„ÇíÈÄÅ‰ø°
        try {
          chrome.runtime.sendMessage({
            action: 'tabRemoved',
            tabId: tabId,
            notebookId: poolEntry.notebookId
          });
        } catch (e) {
          // „Ç®„É©„Éº„ÇíÁÑ°Ë¶ñ
        }
      }
      
      this.pool.delete(tabId);
      
      // Remove from cache if it was cached
      if (poolEntry.notebookId) {
        const cachedInfo = this.audioCache.get(poolEntry.notebookId);
        if (cachedInfo && cachedInfo.tabId === tabId) {
          // „Ç≠„É£„ÉÉ„Ç∑„É•„ÅØ‰øùÊåÅ„Åô„Çã„Åå„ÄÅtabId„Å†„Åë„ÇØ„É™„Ç¢
          cachedInfo.tabId = null;
        }
      }
      
      // Maintain minimum pool
      setTimeout(() => this.ensureMinimumPool(), 1000);
    }
  }

  handleTabCrashed(tabId) {
    console.log(`Tab ${tabId} crashed`);
    this.handleTabRemoved(tabId);
  }

  startPeriodicCleanup() {
    // Clean up every 5 minutes
    setInterval(() => {
      this.performCleanup();
    }, 5 * 60 * 1000);
  }

  async performCleanup() {
    const now = Date.now();
    const maxIdleTime = 60 * 60 * 1000; // 60ÂàÜ„Å´Âª∂Èï∑ÔºàÈü≥Â£∞„ÇíÈï∑„Åè‰øùÊåÅÔºâ
    const maxCacheTime = 3 * 60 * 60 * 1000; // 3ÊôÇÈñì„Ç≠„É£„ÉÉ„Ç∑„É•‰øùÊåÅ
    
    // Clean up old idle tabs
    for (const [tabId, entry] of this.pool.entries()) {
      if (entry.state === 'idle' && 
          entry.lastUsed && 
          (now - entry.lastUsed) > maxIdleTime) {
        try {
          await chrome.tabs.remove(tabId);
          console.log(`Removed stale tab ${tabId}`);
        } catch (error) {
          console.error('Failed to remove stale tab:', error);
        }
      }
    }
    
    // Clean up old cache entries
    for (const [notebookId, cacheEntry] of this.audioCache.entries()) {
      if ((now - cacheEntry.cachedAt) > maxCacheTime) {
        this.audioCache.delete(notebookId);
        console.log(`Removed stale cache for notebook ${notebookId}`);
      }
    }
    
    // Ensure minimum pool
    await this.ensureMinimumPool();
  }

  getStats() {
    const entries = Array.from(this.pool.values());
    return {
      totalTabs: this.pool.size,
      idleTabs: entries.filter(e => e.state === 'idle').length,
      inUseTabs: entries.filter(e => e.state === 'in_use').length,
      cacheSize: this.audioCache.size,
      tabs: entries.map(e => ({
        tabId: e.tabId,
        state: e.state,
        notebookId: e.notebookId,
        lastUsed: e.lastUsed
      }))
    };
  }

  /**
   * „Çø„Éñ„Ç∞„É´„Éº„Éó„ÇíÂèñÂæó„Åæ„Åü„ÅØ‰ΩúÊàê
   */
  async getOrCreateGroup() {
    try {
      // Êó¢Â≠ò„ÅÆ„Ç∞„É´„Éº„Éó„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
      if (this.groupId) {
        try {
          const group = await chrome.tabGroups.get(this.groupId);
          if (group) return this.groupId;
        } catch (e) {
          // „Ç∞„É´„Éº„Éó„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ
          this.groupId = null;
        }
      }

      // Êó¢Â≠ò„ÅÆ„Ç∞„É´„Éº„Éó„ÇíÊ§úÁ¥¢
      const groups = await chrome.tabGroups.query({});
      const existingGroup = groups.find(g => g.title === this.groupTitle);
      
      if (existingGroup) {
        this.groupId = existingGroup.id;
        return this.groupId;
      }

      // Êñ∞„Åó„ÅÑ„Ç∞„É´„Éº„Éó„ÅØÂæå„Åß‰ΩúÊàêÔºà„Çø„Éñ„ÇíËøΩÂä†„Åô„ÇãÊôÇÔºâ
      return null;
    } catch (error) {
      console.error('Failed to get or create tab group:', error);
      return null;
    }
  }

  /**
   * „Çø„Éñ„Çí„Ç∞„É´„Éº„Éó„Å´ËøΩÂä†
   */
  async addTabToGroup(tabId) {
    try {
      // Chrome 89‰ª•Èôç„Åß„ÅÆ„ÅøÂà©Áî®ÂèØËÉΩ
      if (!chrome.tabGroups) {
        console.log('Tab groups API not available');
        return;
      }

      let groupId = await this.getOrCreateGroup();
      
      // „Ç∞„É´„Éº„Éó„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ„Çø„Éñ„Çí„Ç∞„É´„Éº„ÉóÂåñ„Åó„Å¶Êñ∞Ë¶è‰ΩúÊàê
      if (!groupId) {
        groupId = await chrome.tabs.group({ tabIds: [tabId] });
        this.groupId = groupId;
        
        // „Ç∞„É´„Éº„Éó„ÅÆË®≠ÂÆö
        await chrome.tabGroups.update(groupId, {
          title: this.groupTitle,
          color: this.groupColor,
          collapsed: true  // „Ç∞„É´„Éº„Éó„ÇíÊäò„Çä„Åü„Åü„Çì„ÅßÁõÆÁ´ã„Åü„Å™„Åè„Åô„Çã
        });
      } else {
        // Êó¢Â≠ò„ÅÆ„Ç∞„É´„Éº„Éó„Å´ËøΩÂä†
        await chrome.tabs.group({ 
          tabIds: [tabId], 
          groupId: groupId 
        });
        
        // „Ç∞„É´„Éº„Éó„ÅåÂ±ïÈñã„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÊäò„Çä„Åü„Åü„ÇÄ
        try {
          const group = await chrome.tabGroups.get(groupId);
          if (!group.collapsed) {
            await chrome.tabGroups.update(groupId, { collapsed: true });
          }
        } catch (e) {
          console.log('Failed to collapse group:', e);
        }
      }
      
      return groupId;
    } catch (error) {
      console.error('Failed to add tab to group:', error);
      return null;
    }
  }
}

// Initialize tab pool manager
let tabPoolManager = null;

// Initialize stats collector
let statsCollector = null;

// Initialize tab focus manager
let tabFocusManager = null;

// Stats Collector - inline implementation for Service Worker
class StatsCollector {
  constructor() {
    this.STORAGE_KEY = 'notebookStats';
    this.SESSION_KEY = 'activeSessions';
    this.currentSessions = new Map();
  }

  static getInstance() {
    if (!StatsCollector.instance) {
      StatsCollector.instance = new StatsCollector();
    }
    return StatsCollector.instance;
  }

  async startSession(notebookId, notebookTitle, icon = 'üìö') {
    const sessionId = `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const session = {
      sessionId,
      notebookId,
      notebookTitle,
      icon,
      startTime: new Date().toISOString(),
      endTime: null,
      duration: 0,
      completionRate: 0,
      events: [{
        type: 'start',
        timestamp: new Date().toISOString()
      }],
      isPaused: false,
      pausedDuration: 0
    };

    this.currentSessions.set(sessionId, session);
    await this.saveActiveSessions();
    
    return sessionId;
  }

  async endSession(sessionId, completionRate = 0) {
    const session = this.currentSessions.get(sessionId);
    if (!session) return;

    session.endTime = new Date().toISOString();
    session.completionRate = Math.min(1, Math.max(0, completionRate));
    
    const totalTime = new Date(session.endTime) - new Date(session.startTime);
    session.duration = Math.round((totalTime - session.pausedDuration) / 1000);

    session.events.push({
      type: 'end',
      timestamp: session.endTime,
      completionRate: session.completionRate
    });

    await this.saveSessionToStats(session);
    
    this.currentSessions.delete(sessionId);
    await this.saveActiveSessions();
  }

  async recordEvent(sessionId, eventType, metadata = {}) {
    const session = this.currentSessions.get(sessionId);
    if (!session) return;

    session.events.push({
      type: eventType,
      timestamp: new Date().toISOString(),
      ...metadata
    });

    await this.saveActiveSessions();
  }

  async saveActiveSessions() {
    const sessions = Array.from(this.currentSessions.values());
    await chrome.storage.local.set({ [this.SESSION_KEY]: sessions });
  }

  async saveSessionToStats(session) {
    try {
      const stats = await this.getStats();
      
      if (!stats.sessions) stats.sessions = [];
      stats.sessions.push(session);

      const date = new Date(session.startTime).toISOString().split('T')[0];
      if (!stats.dailyStats) stats.dailyStats = {};
      if (!stats.dailyStats[date]) {
        stats.dailyStats[date] = {
          totalSessions: 0,
          totalDuration: 0,
          uniqueNotebooks: [],
          completedSessions: 0
        };
      }

      const dailyStat = stats.dailyStats[date];
      dailyStat.totalSessions++;
      dailyStat.totalDuration += session.duration;
      if (!dailyStat.uniqueNotebooks.includes(session.notebookId)) {
        dailyStat.uniqueNotebooks.push(session.notebookId);
      }
      if (session.completionRate >= 0.9) {
        dailyStat.completedSessions++;
      }

      // 90Êó•‰ª•‰∏äÂâç„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÂâäÈô§
      const ninetyDaysAgo = new Date();
      ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
      stats.sessions = stats.sessions.filter(s => 
        new Date(s.startTime) > ninetyDaysAgo
      );

      await chrome.storage.local.set({ [this.STORAGE_KEY]: stats });
    } catch (error) {
      console.error('Failed to save session stats:', error);
    }
  }

  async getStats() {
    try {
      const result = await chrome.storage.local.get(this.STORAGE_KEY);
      return result[this.STORAGE_KEY] || {
        sessions: [],
        dailyStats: {},
        notebookStats: {}
      };
    } catch (error) {
      console.error('Failed to get stats:', error);
      return {
        sessions: [],
        dailyStats: {},
        notebookStats: {}
      };
    }
  }
}

// Initialize on extension install or startup
chrome.runtime.onInstalled.addListener(async () => {
  console.log('Extension installed/updated');
  await initializeTabPoolManager();
});

chrome.runtime.onStartup.addListener(async () => {
  console.log('Extension started');
  await initializeTabPoolManager();
});

// Also initialize immediately for development
initializeTabPoolManager();
initializeStatsCollector();

async function initializeStatsCollector() {
  if (!statsCollector) {
    try {
      statsCollector = StatsCollector.getInstance();
      console.log('Stats collector initialized successfully');
    } catch (error) {
      console.error('Failed to initialize stats collector:', error);
    }
  }
}

async function initializeTabPoolManager() {
  if (!tabPoolManager) {
    try {
      tabPoolManager = new TabPoolManager();
      await tabPoolManager.initialize();
      console.log('Tab pool manager initialized successfully');
    } catch (error) {
      console.error('Failed to initialize tab pool manager:', error);
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Å®„Åó„Å¶ÊúÄÂ∞èÈôê„ÅÆÊ©üËÉΩ„ÇíÊèê‰æõ
      tabPoolManager = {
        getAvailableTab: async (notebookId) => {
          // „Ç∑„É≥„Éó„É´„Å´Êñ∞„Åó„ÅÑ„Çø„Éñ„Çí‰ΩúÊàê
          const tab = await chrome.tabs.create({
            url: 'https://notebooklm.google.com',
            active: false
          });
          return tab.id;
        },
        navigateTab: async (tabId, url) => {
          await chrome.tabs.update(tabId, { url });
        },
        releaseTab: (tabId) => {
          // Âç≥Â∫ß„Å´„Çø„Éñ„ÇíÂâäÈô§
          chrome.tabs.remove(tabId).catch(() => {});
        },
        getCachedAudioInfo: () => null,
        cacheAudioInfo: () => {},
        getStats: () => ({ totalTabs: 0, idleTabs: 0, inUseTabs: 0 })
      };
    }
  }
}

// Tab Focus Manager - inline implementation
class TabFocusManager {
  constructor() {
    this.userActiveTab = null;
    this.isManagingFocus = false;
  }

  initialize() {
    // „Çø„Éñ„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Å™„Å£„Åü„Å®„Åç„ÅÆÁõ£Ë¶ñ
    chrome.tabs.onActivated.addListener(async (activeInfo) => {
      if (this.isManagingFocus) return;
      
      try {
        const tab = await chrome.tabs.get(activeInfo.tabId);
        
        // NotebookLM„ÅÆÈü≥Â£∞„Çø„Éñ„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´„Å™„Å£„ÅüÂ†¥Âêà
        if (tab.url && tab.url.includes('notebooklm.google.com') && 
            this.userActiveTab && this.userActiveTab !== activeInfo.tabId) {
          
          // „Çø„Éñ„Ç∞„É´„Éº„Éó„Å´Â±û„Åó„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
          if (tab.groupId && tab.groupId !== chrome.tabGroups.TAB_GROUP_ID_NONE) {
            const group = await chrome.tabGroups.get(tab.groupId);
            
            // Èü≥Â£∞ÂÜçÁîüÁî®„ÅÆ„Ç∞„É´„Éº„Éó„ÅÆÂ†¥Âêà
            if (group.title === 'üìö NotebookLM Èü≥Â£∞') {
              this.isManagingFocus = true;
              
              // ÂÖÉ„ÅÆ„Çø„Éñ„Å´Âç≥Â∫ß„Å´„Éï„Ç©„Éº„Ç´„Çπ„ÇíÊàª„Åô
              await chrome.tabs.update(this.userActiveTab, { active: true });
              
              // „Ç∞„É´„Éº„Éó„ÇíÊäò„Çä„Åü„Åü„ÇÄ
              await chrome.tabGroups.update(tab.groupId, { collapsed: true });
              
              this.isManagingFocus = false;
            }
          }
        } else if (!tab.url?.includes('notebooklm.google.com')) {
          // „É¶„Éº„Ç∂„Éº„ÅåÊÑèÂõ≥ÁöÑ„Å´Âà•„ÅÆ„Çø„Éñ„ÇíÈñã„ÅÑ„Åü
          this.userActiveTab = activeInfo.tabId;
        }
      } catch (error) {
        console.error('Focus management error:', error);
        this.isManagingFocus = false;
      }
    });
  }

  async recordCurrentActiveTab() {
    try {
      const [activeTab] = await chrome.tabs.query({ active: true, currentWindow: true });
      if (activeTab) {
        this.userActiveTab = activeTab.id;
      }
    } catch (error) {
      console.error('Failed to record active tab:', error);
    }
  }
}

async function initializeTabFocusManager() {
  if (!tabFocusManager) {
    try {
      tabFocusManager = new TabFocusManager();
      tabFocusManager.initialize();
      console.log('Tab focus manager initialized successfully');
    } catch (error) {
      console.error('Failed to initialize tab focus manager:', error);
    }
  }
}

// „Çµ„Ç§„Éâ„Éë„Éç„É´„ÅÆË®≠ÂÆö
chrome.sidePanel
  .setPanelBehavior({ openPanelOnActionClick: true })
  .catch((error) => console.error(error));

// Êã°ÂºµÊ©üËÉΩ„ÅÆ„Ç¢„Ç§„Ç≥„É≥„ÇØ„É™„ÉÉ„ÇØÊôÇ„ÅÆÂá¶ÁêÜ
chrome.action.onClicked.addListener((tab) => {
  chrome.sidePanel.open({ windowId: tab.windowId });
});

// „É°„ÉÉ„Çª„Éº„Ç∏„É™„Çπ„Éä„ÉºÔºà„Ç≥„É≥„ÉÜ„É≥„Éà„Çπ„ÇØ„É™„Éó„Éà„Å®„ÅÆÈÄö‰ø°Áî®Ôºâ
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  // ÈùûÂêåÊúüÂá¶ÁêÜ„ÅÆ„Åü„ÇÅ„ÅÆ„É©„ÉÉ„Éë„ÉºÈñ¢Êï∞
  (async () => {
  if (request.action === 'getNotebooks') {
    // NotebookLM„Åã„ÇâÂèñÂæó„Åó„Åü„Éá„Éº„Çø„Çí„Çµ„Ç§„Éâ„Éë„Éç„É´„Å´ÈÄÅ‰ø°
    chrome.runtime.sendMessage({
      action: 'updateNotebooks',
      data: request.data
    });
  } else if (request.action === 'audioProgressUpdate') {
    // Èü≥Â£∞ÈÄ≤Ë°åÁä∂Ê≥Å„ÅÆÊõ¥Êñ∞„Çí„Çµ„Ç§„Éâ„Éë„Éç„É´„Å´Ëª¢ÈÄÅ
    chrome.runtime.sendMessage({
      action: 'audioProgressUpdate',
      data: request.data,
      tabId: sender.tab?.id
    });
  } else if (request.action === 'getPooledTab') {
    // Handle tab pool requests
    handleTabPoolRequest(request, sendResponse);
    return true; // Will respond asynchronously
  } else if (request.action === 'releaseTab') {
    // Release tab back to pool
    if (tabPoolManager) {
      tabPoolManager.releaseTab(request.tabId, request.autoClose);
    }
    sendResponse({ success: true });
  } else if (request.action === 'getPoolStats') {
    // Get pool statistics
    const stats = tabPoolManager ? tabPoolManager.getStats() : null;
    sendResponse({ stats });
  } else if (request.action === 'cacheAudioInfo') {
    // Cache audio info for a tab
    if (tabPoolManager && request.tabId && request.audioInfo) {
      tabPoolManager.cacheAudioInfo(request.tabId, request.audioInfo);
    }
    sendResponse({ success: true });
  } else if (request.action === 'startStatsSession') {
    // Start statistics session
    if (!statsCollector) await initializeStatsCollector();
    const sessionId = await statsCollector.startSession(
      request.notebookId,
      request.notebookTitle,
      request.icon
    );
    sendResponse(sessionId);
  } else if (request.action === 'endStatsSession') {
    // End statistics session
    if (statsCollector && request.sessionId) {
      await statsCollector.endSession(request.sessionId, request.completionRate || 0);
    }
    sendResponse({ success: true });
  } else if (request.action === 'recordStatsEvent') {
    // Record statistics event
    if (statsCollector && request.sessionId) {
      await statsCollector.recordEvent(
        request.sessionId,
        request.eventType,
        request.metadata
      );
    }
    sendResponse({ success: true });
  }
  })();
  return true;
});

// Handle tab pool requests
async function handleTabPoolRequest(request, sendResponse) {
  try {
    if (!tabPoolManager) {
      await initializeTabPoolManager();
    }
    
    // Get an available tab from the pool
    const tabId = await tabPoolManager.getAvailableTab(request.notebookId);
    
    // If a specific notebook URL is requested, navigate to it
    if (request.notebookUrl) {
      await tabPoolManager.navigateTab(tabId, request.notebookUrl);
    }
    
    // Check for cached audio info
    const cachedAudioInfo = tabPoolManager.getCachedAudioInfo(tabId);
    
    sendResponse({ 
      success: true, 
      tabId,
      cachedAudioInfo
    });
  } catch (error) {
    console.error('Tab pool request error:', error);
    sendResponse({ 
      success: false, 
      error: error.message 
    });
  }
}

// Offscreen„Éâ„Ç≠„É•„É°„É≥„Éà„ÅÆ‰ΩúÊàê
async function createOffscreenDocument() {
  if (await chrome.offscreen.hasDocument()) return;
  
  await chrome.offscreen.createDocument({
    url: chrome.runtime.getURL('src/offscreen/offscreen.html'),
    reasons: ['AUDIO_PLAYBACK'],
    justification: 'NotebookLM„ÅÆÈü≥Â£∞Ê¶ÇË¶Å„ÇíÂÜçÁîü„Åô„Çã„Åü„ÇÅ'
  });
}

// Offscreen„Éâ„Ç≠„É•„É°„É≥„Éà„Å∏„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
async function sendToOffscreen(message) {
  await createOffscreenDocument();
  
  return new Promise((resolve) => {
    chrome.runtime.sendMessage({
      ...message,
      target: 'offscreen'
    }, response => {
      resolve(response);
    });
  });
}

// Êã°ÂºµÊ©üËÉΩ„ÅåËµ∑Âãï„Åó„Åü„Å®„Åç„ÅÆÂàùÊúüÂåñ
chrome.runtime.onStartup.addListener(async () => {
  await initializeTabPoolManager();
  await initializeStatsCollector();
  await initializeTabFocusManager();
});

// Êã°ÂºµÊ©üËÉΩ„Åå„Ç§„É≥„Çπ„Éà„Éº„É´/Êõ¥Êñ∞„Åï„Çå„Åü„Å®„Åç„ÅÆÂàùÊúüÂåñ
chrome.runtime.onInstalled.addListener(async () => {
  await initializeTabPoolManager();
  await initializeStatsCollector();
  await initializeTabFocusManager();
});